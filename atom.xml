<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huran111.github.io</id>
    <title>胡的博客</title>
    <updated>2019-09-29T04:22:19.079Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huran111.github.io"/>
    <link rel="self" href="https://huran111.github.io/atom.xml"/>
    <subtitle>知其然，知其所以然</subtitle>
    <logo>https://huran111.github.io/images/avatar.png</logo>
    <icon>https://huran111.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 胡的博客</rights>
    <entry>
        <title type="html"><![CDATA[HDFS组成架构]]></title>
        <id>https://huran111.github.io/post/hdfs-zu-cheng-jia-gou</id>
        <link href="https://huran111.github.io/post/hdfs-zu-cheng-jia-gou">
        </link>
        <updated>2019-08-05T03:21:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="namenode">NameNode</h3>
<ul>
<li>就是Master，它是一个主管，管理者。
+ 管理HDFS的名称空间
+ 配置副本策略
+ 管理数据块映射信息
+ 处理客户端读写请求</li>
</ul>
<h3 id="datanode">DataNode</h3>
<ul>
<li>Slave ,NameNode下达命令，DataNode执行实际的操作。
<ul>
<li>存储实际的数据块</li>
<li>执行数据块的读写操作</li>
</ul>
</li>
</ul>
<h3 id="client-就是客户端">Client 就是客户端</h3>
<ul>
<li>文件切片，文件上传HDFS的时候，Client将文件切分成一个个的Block，然后进行上传</li>
<li>与NameNode交互，获取文件的位置信息</li>
<li>与DataNode交互，读取或者写入数据</li>
<li>Client提供一些命令来管理HDFS，比如NameNode 格式化</li>
<li>Client可以通过一些命令来访问HDFS,比如对HDFS增删查改操作</li>
</ul>
<h3 id="secondarynamenode-并非namenode的热备当namenode挂掉的时候它并不能替换namenode提供服务">SecondaryNameNode ：并非NameNode的热备，当NameNode挂掉的时候，它并不能替换NameNode提供服务</h3>
<ul>
<li>辅助NameNode,分担其工作量，比如定期合并Fsimage和Edits，并推送给NameNode；</li>
</ul>
<h3 id="hsfs的文件大小">HSFS的文件大小</h3>
<ul>
<li>老版本是64M,新版本是128M</li>
<li>HDFS的块设置的太小，会增加寻址时间，程序一直再找块的开始位置
<ul>
<li>如果块设置太大，从磁盘传输数据的时间就会明显大于定位这个块开始位置所需的时间，导致 程序处理这块数据的时候会非常慢。</li>
<li>块大小 主要取决的磁盘性能</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[享元模式]]></title>
        <id>https://huran111.github.io/post/xiang-yuan-mo-shi</id>
        <link href="https://huran111.github.io/post/xiang-yuan-mo-shi">
        </link>
        <updated>2019-07-17T06:43:43.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>享元模式能够解决重复对象的内存浪费问题，当系统中有大量相似的对象，需要缓冲池，不需要总是创建对象，可以从缓冲池里面拿。</li>
<li><img src="https://huran111.github.io/post-images/1563346983047.png" alt=""></li>
<li>FlyWeight是抽象的享元角色，它是产品的抽象类型，同时定义出对象的外部状态和内部状态</li>
<li>ConcreatFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色相关业务。
+FlyWeightFactory享元工厂类，构建一个容器。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[程序变慢的分析]]></title>
        <id>https://huran111.github.io/post/cheng-xu-bian-man-de-fen-xi</id>
        <link href="https://huran111.github.io/post/cheng-xu-bian-man-de-fen-xi">
        </link>
        <updated>2019-07-04T06:50:19.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>top查看整机的CPU，和内存 平均负载</li>
<li><img src="https://huran111.github.io/post-images/1562223181383.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1562223431688.png" alt=""></li>
<li>查看CPU-vmstat</li>
<li><img src="https://huran111.github.io/post-images/1562223534688.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1562225055548.png" alt=""></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis-HyperLogLog]]></title>
        <id>https://huran111.github.io/post/redis-hyperloglog</id>
        <link href="https://huran111.github.io/post/redis-hyperloglog">
        </link>
        <updated>2019-06-27T09:46:06.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>redis提供了HyPerLogLog数据结构就就是用来解决这种统计问题，它提供了不精确的去重计数方案，虽然不是很精确，误差在0.81，但是已经可以满足上面UV统计需求了。</p>
</li>
<li>
<p>HyperLogLog 提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。</p>
</li>
<li>
<p>HyperLogLog 除了上面的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于将多个 pf 计数值累加在一起形成一个新的 pf 值。</p>
</li>
<li>
<p>比如在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 pfmerge 就可以派上用场了。</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1561629023523.png" alt=""></p>
</li>
<li>
<p>HyperLogLog 实现原理</p>
</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql有时会选错索引？]]></title>
        <id>https://huran111.github.io/post/mysql-you-shi-hui-xuan-cuo-suo-yin</id>
        <link href="https://huran111.github.io/post/mysql-you-shi-hui-xuan-cuo-suo-yin">
        </link>
        <updated>2019-06-27T01:29:24.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><img src="https://huran111.github.io/post-images/1561599356731.png" alt=""></li>
<li>插入10W行数据，select * from t where a between 10000 and 20000; 查看执行计划</li>
<li><img src="https://huran111.github.io/post-images/1561599400795.png" alt=""></li>
<li>select * from t where (a between 1 and 1000)  and (b between 50000 and 100000) order by b limit 1;</li>
<li>上面的语句，如果按照a进行查询，那么就是扫描a的前1000个值，然后取到对应的id，在到主键上查出每一行，然后根据B字段来过滤，显然需要扫描1000行。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[elasticsearch(一)]]></title>
        <id>https://huran111.github.io/post/elasticsearchyi</id>
        <link href="https://huran111.github.io/post/elasticsearchyi">
        </link>
        <updated>2019-06-24T06:24:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>查看节点健康情况</li>
<li>GET /_cat/health?v</li>
<li>绿色 一切正常集群功能齐全</li>
<li>黄色——所有数据可用，但有些副本尚未分配(集群功能完全)</li>
<li>红色——有些数据由于某种原因不可用(集群部分功能)</li>
<li>注意：当集群为红色时，它将继续从可用碎片中提供搜索请求，但是您可能需要尽快修复它，因为存在未分配的碎片。</li>
<li><img src="https://huran111.github.io/post-images/1561359907050.png" alt=""></li>
<li>查看所有的索引  GET /_cat/indices?v</li>
<li><img src="https://huran111.github.io/post-images/1561359922693.png" alt=""></li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql事务隔离]]></title>
        <id>https://huran111.github.io/post/mysql-shi-wu-ge-chi2</id>
        <link href="https://huran111.github.io/post/mysql-shi-wu-ge-chi2">
        </link>
        <updated>2019-06-21T02:45:58.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ACID:原子性，一致性，隔离性，持久性</li>
<li>脏读，不可重复读，幻读</li>
<li>隔离级别：读未提交，读提交，可重复读，串行化
<ul>
<li>读未提交：一个事务还没提交时，它做的变化就能被其他事务看到</li>
<li>读提交：一个事务提交之后，它做的变化才能被其他事务看到</li>
<li>可重复读：一个事务执行的过程中看到的数据，总是跟这个事务在启动时候看到的数据是一致的。 当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化：写会加锁，读会加锁。</li>
<li>例子：创建一个Innodb的表</li>
<li><img src="https://huran111.github.io/post-images/1561085875549.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1561085903921.png" alt=""></li>
<li>查看当前会话的隔离级别</li>
<li><img src="https://huran111.github.io/post-images/1561086181670.png" alt=""></li>
<li>查看系统的隔离级别</li>
<li><img src="https://huran111.github.io/post-images/1561086214373.png" alt=""></li>
<li>设置会话的隔离级别，隔离级别由低到高设置依次为:</li>
<li>set session transaction isolation level read uncommitted;</li>
<li>set session transaction isolation level read committed;</li>
<li>set session transaction isolation level repeatable read;</li>
<li>set session transaction isolation level serializable;</li>
</ul>
</li>
<li><strong>(1) 将当前会话的隔离级别设置为读未提交</strong></li>
<li><img src="https://huran111.github.io/post-images/1561087288815.png" alt=""></li>
<li><strong>(2) 将当前会话的隔离级别设置为读提交</strong></li>
<li><img src="https://huran111.github.io/post-images/1561087817551.png" alt=""></li>
<li><strong>(3) 将当前会话的隔离级别设置为可重复读</strong></li>
<li><img src="https://huran111.github.io/post-images/1561088709444.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1561088933068.png" alt="">
<strong>事务隔离的实现</strong></li>
<li>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</li>
<li><img src="https://huran111.github.io/post-images/1561096570337.png" alt=""></li>
<li>事务的启动方式</li>
<li>1 显示启动  start transaction -commint 回滚是rollback</li>
<li>2 set autocommit=0 将线程的自动提交关闭，意味着手动执行一个select 事务就开启了 ，而且并不会自动提交。建议set autocommit=1</li>
<li>也可以用 commit work and chain 意思是提交事务并自动进入下一个事务。</li>
<li>查询长事务：select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</li>
</ul>
<h3 id="事务到底是隔离还是不隔离">事务到底是隔离还是不隔离</h3>
<ul>
<li><img src="https://huran111.github.io/post-images/1561377409110.png" alt=""></li>
<li>Mysql里面视图有两个概念
<ul>
<li>一个是view,查询定义的虚拟表。</li>
<li>另一个是Innodb在实现MVCC用到的一致性读视图，由于支持RC和RR的实现。</li>
<li>快照在MVCC是如何工作的?
<ul>
<li>在可重复读级别下，事务在启动的时候就拍了个快照，基于整个库的（并没有拷贝数据）</li>
<li>InnoDB每个事务都有一个唯一的事务Id，transaction id。在事务开始的时候想InnoDB中事务系统申请的，严格递增。</li>
<li>每行数据也有多个版本。每次事务更新数据，就会生成一个版本。把这个事务id赋值给新的数据版本的事务id，旧版本保留。</li>
<li>下图就是记录一个被多个事务连续更新后的状态</li>
<li><img src="https://huran111.github.io/post-images/1561424334675.png" alt=""></li>
<li>InnoDB是如何定义那个&quot;100G&quot;的快照的，按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果，但是之后，这个事务执行期间，其他事务的更新对它不可见。</li>
<li>实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，正在活跃的事务ID,就是值启动了还没有提交。</li>
<li>一个数据版本，对于一个视图来说，除了自己的更新总是可以见的，另外有三种情况
<ul>
<li>版本未提交，不可见</li>
<li>版本已经提交，但是是在视图创建后提交的，不可见</li>
<li>版本已经提交，而且实在视图创建前提交的，可见</li>
<li>InnoDB的行数据有多个版本，每个数据版本都有自己的row_trx_id,每个事务或者语句有自己的一致性视图，普通查询语句是一致性读，一致性读会根据row_trx_id和一致性视图确定数据版本的可见性。</li>
<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据。
+ 对于读提交，查询只承认在语句启动前就已经提交完成的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一条sql是如何更新的]]></title>
        <id>https://huran111.github.io/post/yi-tiao-sql-shi-ru-he-geng-xin-de</id>
        <link href="https://huran111.github.io/post/yi-tiao-sql-shi-ru-he-geng-xin-de">
        </link>
        <updated>2019-06-20T10:57:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code>	+ 更新流程设计两个模块一个是redo log(重做日志),一个是binlog(归档日志)，Mysql里面有一个问题如果每次更新操作都需要写入磁盘，然后磁盘也要找到对应的那条记录，然后在更新，整个过程的IO成本都很高。 WAL技术也就是先写日志在写磁盘。
	+ 当一条记录需要更新的时候，InnoDB就会先把记录写到redo log里面，并更新内存，这个时候就算完成了，同时，Innodb引擎在适当的时候，将这个操作更新到磁盘里面。
	+ Innodb的redo log是固定大小的，可以配置一组为4个文件，每个文件1GB,从头开始写，写到末尾又回到开头循环写。
	+  有了redolog,Innodb就可以保证数据库发生异常重启，之前提交的记录都不会丢失，这个称为crash-safe
	+  redo log是Innodb层的，binlog是Mysql Server层的。
	+  两种日志的不同
	  + redolog是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是这个语句的原始逻辑。
	  + redolog是循环写，会覆盖，空间会用完，binlog是追加写，不会覆盖。
	  + update的语句时的执行流程
	  + ![](https://huran111.github.io/post-images/1561030115679.png)
	  + redolog被拆成了两个步骤，准备和提交
</code></pre>
<ul>
<li><strong>两阶段提交</strong>
<ul>
<li>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据
<ul>
<li>找到最近的一次全量备份</li>
<li>从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
</li>
<li>由于redolog和binlog是两个独立的逻辑，如果不用两阶段提交会有什么问题？</li>
<li>以 update T set c=c+1 where ID=2 为例</li>
<li><img src="https://huran111.github.io/post-images/1561084826449.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1561084866299.png" alt="">
<ul>
<li><img src="https://huran111.github.io/post-images/1561029787476.png" alt=""></li>
<li>0：每秒将log buffer的内容写事务日志并且刷新到磁盘；</li>
<li>1：每个事务提交后，将log_buffer的内容写事务日志并刷新数据到磁盘；</li>
<li>2：每个事务提交，将log_buffer内容写事务日志，但不进行数据刷盘</li>
<li>mysql默认log_bin是关闭的</li>
<li><img src="https://huran111.github.io/post-images/1561030522520.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一条sql语句是如何执行的]]></title>
        <id>https://huran111.github.io/post/yi-tiao-sql-yu-ju-shi-ru-he-zhi-xing-de</id>
        <link href="https://huran111.github.io/post/yi-tiao-sql-yu-ju-shi-ru-he-zhi-xing-de">
        </link>
        <updated>2019-06-20T09:04:53.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>当我们输入 mysql&gt; select * from T where id=1的时候
<ul>
<li><img src="https://huran111.github.io/post-images/1561022192410.png" alt=""></li>
<li>Server层包括连接器，查询缓存，分析器，优化器，执行器等，以及所有的内置函数，所有跨存着引擎的功能都在这一层实现，比如存储过程，触发器，视图等。</li>
<li>存储引擎负责数据的存储和读取，支持Innodb,MyISAM等，常用Innodb,从Mysql5.5.5成了默认。</li>
<li><strong>连接器</strong>
<ul>
<li>mysql -h<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>p</mi><mo>−</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">ip -P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>port -u$user -p</li>
<li>连接完成后，如果没有后续操作，连接就处于空闲状态，执行命令查看</li>
<li><img src="https://huran111.github.io/post-images/1561023099898.png" alt=""></li>
<li>客户端默认8小时，参数由wait_timeout控制</li>
<li><em>Mysql在执行过程中临时使用的内存是管理在连接对象里面的，断开后才会释放。</em></li>
<li>解决办法，定期断开长连接，再重连，也可执行mysql_reset_connection重新初始化资源（mysql5.7）</li>
</ul>
</li>
<li><strong>查询缓存</strong>
+ 执行一个语句后先看看缓存中有没有,(key-value键值对)key是查询的语句，value是结果，如果拿到直接返回客户端
+ 注意：不建议使用缓存，弊大于利，缓存失效频繁，只有对一个表有更新，缓存就是失效，将参数 query_cache_type 设置成DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。
+ 查看是否支持
+ <img src="https://huran111.github.io/post-images/1561024305002.png" alt="">
+ 查看参数设置
+ <img src="https://huran111.github.io/post-images/1561024382868.png" alt="">
+ 可以在my.ini配置文件中设置。
+ 也可以显示指定通过sql_cache;
+ <img src="https://huran111.github.io/post-images/1561024668014.png" alt="">
+ Mysql8.0版本直接将查询缓存模块功能删了。
<ul>
<li><strong>分析器</strong>
<ul>
<li>对SQL做解析，词法分析，然后进行语法分析</li>
</ul>
</li>
<li><strong>优化器</strong>
+ sql执行前，进入优化器，可以选择使用哪个索引，多表关联的时候选择表连接的顺序。</li>
<li><strong>执行器</strong></li>
<li>执行前先判断有没有权限，然后开始执行。</li>
<li>1.调用Innodb引擎接口读取表的第一行，判断是否符合条件值，不是跳过，继续读取下一行，重复逻辑，直到全部满足。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis原理]]></title>
        <id>https://huran111.github.io/post/mybatis-yuan-li</id>
        <link href="https://huran111.github.io/post/mybatis-yuan-li">
        </link>
        <updated>2019-06-14T02:53:03.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>主要构件及其相互关系</li>
<li>SqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</li>
<li>ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所需要的参数；</li>
<li>ResultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li>
<li>TypeHandler：负责java数据类型和jdbc数据类型之间的映射和转换；</li>
<li>MappedStatement：MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装；</li>
<li>SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql：表示动态生成的SQL语句以及相应的参数信息；</li>
<li>Configuration：MyBatis所有的配置信息都维持在Configuration对象之中；</li>
<li><img src="https://huran111.github.io/post-images/1560488110683.png" alt=""></li>
<li>首先，我们来看一个例子</li>
<li><img src="https://huran111.github.io/post-images/1560489148557.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560489191829.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560489203828.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560489385433.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491269325.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491303104.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491340414.png" alt=""></li>
<li>缓存的是一个CacheKey Value</li>
<li><img src="https://huran111.github.io/post-images/1560491716290.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491705903.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560492719898.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560493255091.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560493539131.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560495706338.png" alt=""></li>
<li>Executor的功能和作用是</li>
<li>根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用</li>
<li>为查询创建缓存，以提高性能；</li>
<li>创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果；</li>
<li>StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回</li>
<li>prepareStatement() 方法的实现</li>
<li></li>
</ul>
]]></content>
    </entry>
</feed>