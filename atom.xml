<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huran111.github.io</id>
    <title>清风徐来</title>
    <updated>2019-05-29T03:21:27.096Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huran111.github.io"/>
    <link rel="self" href="https://huran111.github.io/atom.xml"/>
    <subtitle>温故而知新-欢迎关注公众号《Java精选笔记》</subtitle>
    <logo>https://huran111.github.io/images/avatar.png</logo>
    <icon>https://huran111.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 清风徐来</rights>
    <entry>
        <title type="html"><![CDATA[Spring Cloud微服务-Eureka+Ribbon]]></title>
        <id>https://huran111.github.io/post/spring-cloud-wei-fu-wu-eurekaribbon</id>
        <link href="https://huran111.github.io/post/spring-cloud-wei-fu-wu-eurekaribbon">
        </link>
        <updated>2019-05-29T03:18:40.000Z</updated>
        <content type="html"><![CDATA[<p>Spring Cloud是什么？</p>
<p>（1）云计算？不是</p>
<p>(2) 依赖于Spring Boot</p>
<p>(3)快速构建分布式系统的工具集-全集桶</p>
<p>2.关于Spring Cloud的版本？</p>
<ul>
<li>
<p>大部分spring软件的版本是以：主版本.次版本.增量版本.里程碑版本的形式命名</p>
</li>
<li>
<p>Spring Cloud特点</p>
<p>+（1）约定优于配置</p>
<p>+（2）开箱即用、快速启动</p>
<p>+（3）适用于各种环境 --PC Serve ---云环境--容器(Docker)</p>
<p>+（4）轻量级的组件-Eureka-服务发现</p>
<ul>
<li>
<p>(5) 组件的支持很丰富，功能很齐全-配置中心--注册中心--智能路由</p>
</li>
<li>
<p>(6) 选型中立--服务发现--Eureka-Zookeeper-Consul</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>需要的技术储备</li>
</ol>
<p>(1)Java/Scala/Groovy...</p>
<p>(2)构建工具--Maven--Gradle</p>
<p>(3)Spring Boot</p>
<p>服务提供者与服务消费者:
<img src="https://huran111.github.io/post-images/1559099978253.png" alt="">
**务发现组件：Eureka
1:什么事Eureka?</p>
<p>(1)Eureka来自生产环境</p>
<p>(2)Spring Cloud对Eureka支持很好</p>
<p>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Spring Cloud将它集成在其子项目spring-cloud-netflix中，以实现Spring Cloud的服务发现功能。</p>
<p>1:Eureka 原理
<img src="https://huran111.github.io/post-images/1559100003664.png" alt="">
<img src="https://huran111.github.io/post-images/1559100009417.png" alt="">
上图是来自Eureka官方的架构图，大致描述了Eureka集群的工作过程。由于图比较复杂，可能比较难看懂，这边用通俗易懂的语言翻译一下：
Application Service 就相当于本书中的服务提供者（用户微服务），
Application Client就相当于本书中的服务消费者（电影微服务）；</p>
<ul>
<li>
<p>Make Remote Call，可以简单理解为调用RESTful的接口；</p>
</li>
<li>
<p>us-east-1c、us-east-1d等是zone，它们都属于us-east-1这个region；
由图可知，Eureka包含两个组件：Eureka Server 和 Eureka Client。
Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。
--- Eureka Client是一个Java客户端，用于简化与Eureka Server的交互，客户端同时也具备一个内置的、使用轮询（round-robin）负载算法的负载均衡器。</p>
</li>
</ul>
<p>在应用启动后，将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除（默认90秒）。
Eureka Server之间将会通过复制的方式完成数据的同步。（详见Eureka高可用章节）
Eureka还提供了客户端缓存的机制，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。
综上，Eureka通过心跳检测、健康检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。
实现Euraka Server和Client: 相关关代码已经放到GitHub上：
https://github.com/huran111</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql事务隔离]]></title>
        <id>https://huran111.github.io/post/mysql-shi-wu-ge-chi</id>
        <link href="https://huran111.github.io/post/mysql-shi-wu-ge-chi">
        </link>
        <updated>2019-05-29T03:09:31.000Z</updated>
        <content type="html"><![CDATA[<p>隔离性和隔离级别</p>
<p>事务，ACID，即原子性，一致性，隔离性，持久性。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读，不可重复读，幻读的问题，就有了隔离的感念。</p>
<p>SQL标准的事务隔离级别包括：读未提交，读提交，可重复读，和串行化。</p>
<p>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。</p>
<p>读提交：一个事务提交之后，它做的变更才会被其他事务看到。</p>
<p>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的，在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>
<p>串行化：对于同一行记录，写会加锁，读会加锁，当出现读写冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行。</p>
<p>栗子，如下语句</p>
<pre><code>       create table T(c int) engine=InnoDB;
       insert into T(c) values(1);
				 ![](https://huran111.github.io/post-images/1559099397233.png)
</code></pre>
<p>若隔离级别是读未提交，则V1的值就是2，这时候事务B虽然还没有提交，但是结果已经被A看到了，因此，V2,V3也都是2</p>
<p>若隔离级别是读提交，则V1是1，V2的值是2，事务B的更新在提交后才能被A看到，所以，V3的值也是2</p>
<p>若隔离级别是可重复读，则V1,V2是1，V3是2，之所以V2还是1，遵循的就是这个要求：事务在执行期间看到数据前后必须是一致的</p>
<p>若隔离级别是串行化，则在事务B执行将1改成2的时候，会被锁住，直到事务A提交后，事务B才可以继续执行，所以从A的角度看，V1,V2值是1，V3值是2</p>
<p>在实现上，数据流里面对创建一个视图，访问的时候以视图的逻辑结果为准，在可重复读，隔离级别下，这个视图在事务启动时创建的，整个事务存在期间都用这个视图，在读提交隔离级别下，这个视图是在每个sql语句开始执行的时候创建的，这里需要注意的是，读未提交隔离级别下直接返回记录上的最新值，没有视图概念，而串行化直接用加锁的方式来避免并行访问。
**事务隔离的实现
以可重读读为例：</p>
<p>在MySql中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>假设一个值从1被按照顺序改成 了2，3，4在回滚日志里面就会有类似下面的记录。
<img src="https://huran111.github.io/post-images/1559099440259.png" alt="">
当前值是4，但是查询这条记录的时候，不同时刻启动是事务会有不同的read-view,如图，在视图A,B,C里面，这一个记录的值分别是1，2，4，同一条记录在系统中可以存多个版本，就是数据库的多版本并发控制，对于read-viewA，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>回滚日志在不需要的时候才删除，系统会判断，当没有事务在需要用到这写回滚日志的时候，就会删除。</p>
<p>在Mysql5.5以及以前的版本，回滚日志是跟数据字典放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小，长事务会占用锁资源，可能拖垮整个库。
**事务的启动方式
Mysql事务启动方式有一下几种：</p>
<p>显式的启动事务语句，begin或者start  transaction，配套的提交语句是commit，回滚语句是rollback。</p>
<p>set autocommit=0 这个命令会将这个线程的自动提交关闭，意味着如果你执行一个select语句，这个事务就启动了，而且并不会自动提交，这个事务持续存在直到你主动执行commit或者rollback语句，或者断开连接。</p>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的I命令，这就导致下来查询都在事务中，如果是长连接，就导致了意外的长事务。因此，建议使用set autocommit=1，通过显式语句方式来启动事务。</p>
<p>可以在information_schema库的 innodb_trx这个表中查询长事务
**为什么不建议使用长事务？以mysql默认级别可重复读为例。
比如，在某个时刻（今天上午9：00点）开启了一个事务（对于可重复隔离别，此时一个视图 read-viewA也创建了）这是一个很长的事务.....</p>
<p>事务A在今天早上9：20的时候，查询了一个记录R1的一个字段f1的值为1......</p>
<p>今天早上9：25的时候，一个事务B（随之而来的read-viewB）也被开启了，它更新了R1.f1的值为2（同时也创建了一个由2到1 的回滚日志），这是一个短事务，事务随后就被commit了。</p>
<p>到了下午六点，长事务A还没有呗commit,为了保证事务在执行期间看到的数据在前后必须是一致的。那些老的事务视图，回滚日志就必须存在了，这就占用了大量的存储空间.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-索引（2）]]></title>
        <id>https://huran111.github.io/post/mysql-suo-yin-2</id>
        <link href="https://huran111.github.io/post/mysql-suo-yin-2">
        </link>
        <updated>2019-05-28T10:24:06.000Z</updated>
        <content type="html"><![CDATA[<p>在下面的表中，执行select * from T where k between 3 and 5,需要执行几次树的搜索操作，会扫描多少行？
<img src="https://huran111.github.io/post-images/1559039084517.png" alt="">
<img src="https://huran111.github.io/post-images/1559039090493.png" alt="">
这条SQL查询语句的执行流程为</p>
<p>在A索引树上找到A=3的记录，取得ID=300</p>
<p>再到ID索引树查到ID=300对应的A3</p>
<p>再回到A索引数取下一个值5，取得ID=600</p>
<p>再回到ID索引树查到ID=600对应的A5</p>
<p>在K索引树取下一个值A=6,不满足条件，循环结束</p>
<p>在这个过程中，回到主键索引树搜索的过程，为回表。这个例子中查询结果所需要的数据只在主键索引上有，所以不得不回表，那么，有没有可能经过索引优化，避免回表的过程呢？
**覆盖索引
如果执行的语句为select id from T where k between 3 and 5 这时只需要查询Id的值，而ID的值已经在A索引树上了，因此直接提供查询结果，不需要回表，在这个查询里面，索引 A已经“覆盖”了我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引减少了树的搜索次数，性能显著提升，所以使用覆盖索引是一个常用的性能优化手段。
栗子：</p>
<p>学生表定义
<img src="https://huran111.github.io/post-images/1559039165559.png" alt="">
学号是学生的唯一标识，如果有根据学号查询学生的信息，只要在学号这个字段上建立索引就够了，在建立一个（学号，姓名）的联合索引，是不是有点浪费空间？</p>
<p>B+树这种索引结构，可以利用索引的最左前缀，来定位记录。
可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当查到所有名字是张三的人时，可以快速定位到ID4，饭后向后遍历得到所有需要的结果。</p>
<p>当你查到所有名字第一个字为张的人，SQL语句为‘张%’,也能用上这个索引</p>
<p>只要满足最左前缀，就可以利用索引加速检索，这个前缀索引可以使联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>在建立联合索引的时候，如何安排索引内的字符顺序？</p>
<p>当有(a,b)两个联合索引后，一般就不需要单独在a上建立索引了，因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>
<p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Elastic-Job——分布式定时任务框架实战]]></title>
        <id>https://huran111.github.io/post/elastic-job-fen-bu-shi-ding-shi-ren-wu-kuang-jia-shi-zhan</id>
        <link href="https://huran111.github.io/post/elastic-job-fen-bu-shi-ding-shi-ren-wu-kuang-jia-shi-zhan">
        </link>
        <updated>2019-05-28T04:42:02.000Z</updated>
        <content type="html"><![CDATA[<p>Elastic-Job是ddframe中dd-job的作业模块中分离出来的分布式弹性作业框架。去掉了和dd-job中的监控和ddframe接入规范部分。该项目基于成熟的开源产品Quartz和Zookeeper及其客户端Curator进行二次开发。 ddframe其他模块也有可独立开源的部分，之前当当曾开源过dd-soa的基石模块DubboX。 项目开源地址：https://github.com/dangdangdotcom/elastic-job
Elastic-Job是ddframe中dd-job的作业模块中分离出来的分布式弹性作业框架。去掉了和dd-job中的监控和ddframe接入规范部分。该项目基于成熟的开源产品Quartz和Zookeeper及其客户端Curator进行二次开发。
**Elastic-Job主要功能
**定时任务： 基于成熟的定时任务作业框架Quartz cron表达式执行定时任务
作业注册中心： 基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。</p>
<p>**作业分片： 将一个任务分片成为多个小任务项在多服务器上同时执行。</p>
<p>**弹性扩容缩容： 运行中的作业服务器崩溃，或新增加n台作业服务器，作业框架将在下次作业执行前重新分片，不影响当前作业执行。</p>
<p>**支持多种作业执行模式： 支持OneOff，Perpetual和SequencePerpetual三种作业模式。</p>
<p>**失效转移： 运行中的作业服务器崩溃不会导致重新分片，只会在下次作业启动时分片。启用失效转移功能可以在本次作业执行过程中，监测其他作业服务器空闲，抓取未完成的孤儿分片项执行。</p>
<p>**运行时状态收集： 监控作业运行时状态，统计最近一段时间处理的数据成功和失败数量，记录作业上次运行开始时间，结束时间和下次运行时间。</p>
<p>**作业停止，恢复和禁用：用于操作作业启停，并可以禁止某作业运行（上线时常用）。</p>
<p>被错过执行的作业重触发：自动记录错过执行的作业，并在上次作业完成后自动触发。可参考Quartz的misfire。</p>
<p>**多线程快速处理数据：使用多线程处理抓取到的数据，提升吞吐量。</p>
<p>**幂等性：重复作业任务项判定，不重复执行已运行的作业任务项。由于开启幂等性需要监听作业运行状态，对瞬时反复运行的作业对性能有较大影响。</p>
<p>**容错处理：作业服务器与Zookeeper服务器通信失败则立即停止作业运行，防止作业注册中心将失效的分片分项配给其他作业服务器，而当前作业服务器仍在执行任务，导致重复执行。</p>
<p>**Spring支持：支持spring容器，自定义命名空间，支持占位符。
** 运维平台：提供运维界面，可以管理作业和注册中心。</p>
<h3 id="目录结构说明">目录结构说明</h3>
<p>lastic-job-core</p>
<p>elastic-job核心模块，只通过Quartz和Curator就可执行分布式作业。</p>
<p>elastic-job-spring</p>
<p>elastic-job对spring支持的模块，包括命名空间，依赖注入，占位符等。</p>
<p>elastic-job-console</p>
<p>elastic-job web控制台，可将编译之后的war放入tomcat等servlet容器中使用。</p>
<p>elastic-job-example</p>
<p>使用例子。</p>
<p>elastic-job-test</p>
<p>测试elastic-job使用的公用类，使用方无需关注。
下面进行实战案例：
本案例是SpringBoot+Jpa+Zookeeper+Elastic-job进行讲解。案例代码已经放到本人GitHub上面，地址为：https://github.com/huran111/elastic-job 可自行下载运行。
(1)项目准备。</p>
<p>1.1 新建三个一样的spring boot项目，在实际生产中 分别部署在三台服务器上。
<img src="https://huran111.github.io/post-images/1559018656404.png" alt="">
1.2 安装zookeeper，安装非常简单，可百度，实际生产可部署三台zookeeper集群做高可用，本项目安装一台作为讲解用。
1.3 引入jar.
<img src="https://huran111.github.io/post-images/1559018719225.png" alt="">
1.4 配置参数
application.yum
<img src="https://huran111.github.io/post-images/1559018739375.png" alt="">
application-dev.yum  具体配置在GitHub上。
<img src="https://huran111.github.io/post-images/1559018752312.png" alt="">
<img src="https://huran111.github.io/post-images/1559018762594.png" alt="">
1.5 配置Job.xml
1.5.1 在启动类上面加入注解
<img src="https://huran111.github.io/post-images/1559018787851.png" alt="">
1.5.2 Job.xml详细配置
<img src="https://huran111.github.io/post-images/1559018803717.png" alt="">
这里三台服务器分成了9片
<img src="https://huran111.github.io/post-images/1559018950785.png" alt="">
(2).数据准备。<br>
实体类：
<img src="https://huran111.github.io/post-images/1559018964639.png" alt="">
（3）生成100条数据，实际场景数据可能会更多（1000万条也是有可能的）。
<img src="https://huran111.github.io/post-images/1559018985931.png" alt="">
(4)运行测试用例可以看到数据已经插入成功，其中random字段作为随机数，不是业务字段，只来后序的分片处理。
<img src="https://huran111.github.io/post-images/1559019000076.png" alt="">
（5）验证
5.1 启动服务器server-01，指定10秒后执行。
可以看到分片数量：0,1,2,3,4,5,6,7,8
<img src="https://huran111.github.io/post-images/1559019023412.png" alt="">
5.2启动服务器server-02，同样指定10秒后执行。
可以看到分片数量：0,1,2,3,4，8
<img src="https://huran111.github.io/post-images/1559019036213.png" alt="">
而此时server-01的分片数量自动变为：4,5,6,7
<img src="https://huran111.github.io/post-images/1559019045770.png" alt="">
5.3 下面我们在启动第三台服务器server-03:
可以看到分片数量：6,7,8
<img src="https://huran111.github.io/post-images/1559019054861.png" alt="">
而此时server-01和server-02有什么变化呢？
<img src="https://huran111.github.io/post-images/1559019064557.png" alt="">
可以看到server-01变成了3,4,5，server-02变成了 0,1,2
<img src="https://huran111.github.io/post-images/1559019079952.png" alt="">
5.4 下面我们关闭一台机器，比如server-03:
<img src="https://huran111.github.io/post-images/1559019089909.png" alt="">
再来查看分片数量;
<img src="https://huran111.github.io/post-images/1559019100068.png" alt="">
什么情况？ 这是基于zookeeper的调度算法，来进行自动分片的，当有一台机器挂了或者加入了会自动分配数量。从而实现分布式调度以及处理大数据量的数据。 分片策略可以看：https://blog.csdn.net/tanga842428/article/details/52689119这篇文章</p>
<p>真正的企业里面怎么用的呢？
还记得刚才模拟的100条数据吧 。正常企业中可能会有几百万或者千万的数据，这里来模拟100条数据怎么分布式处理。</p>
<p>Job类编写如下：实现SimpleJob接口
<img src="https://huran111.github.io/post-images/1559019122344.png" alt="">
分别启动三台服务：查看处理数据情况
--------------------------------------------server-01---------------------------------------------</p>
<p><img src="https://huran111.github.io/post-images/1559019131188.png" alt="">
------------------------------------------------server-02------------------------------------------</p>
<p><img src="https://huran111.github.io/post-images/1559019139364.png" alt="">
------------------------------------------------server-03----------------------------------------
<img src="https://huran111.github.io/post-images/1559019146096.png" alt=""></p>
<p>可以看到 三台服务分别处理了这100条数据，这就是分布式调度的意思。在大数据处理中，可以结合该框架，将同一个项目部署在多台机器上，同属处理大数据量的数据，再结合多线程技术,大大增加了效率。</p>
<p>扩展：如果数据多达千万级，此时对mysql的性能影响会很大，此时建议使用ElasticSearch分布式搜索引擎存储读写频率高的数据。主要定时业务可使用Redis作为分布式锁避免重复执行。</p>
<p>---------------------------------------------控制搭建-----------------------------------------------
控制台手动触发任务：
<img src="https://huran111.github.io/post-images/1559019158960.png" alt="">
<img src="https://huran111.github.io/post-images/1559019165136.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql-索引（1）]]></title>
        <id>https://huran111.github.io/post/mysql1-suo-yin</id>
        <link href="https://huran111.github.io/post/mysql1-suo-yin">
        </link>
        <updated>2019-05-28T03:38:22.000Z</updated>
        <content type="html"><![CDATA[<p>InnoBD使用的B+树索引模型，所以数据都是存储在B+树中的。</p>
<p>每一个索引在InnoDB里面对应一棵B+树。</p>
<p>假如我们有一个主键列为Id的表，表中有字段A,在A上有索引。</p>
<pre><code>create table T(

id int primary key, 

A int not null, 

name varchar(16),

index (A))engine=InnoDB;
</code></pre>
<p>表中A1-A5的（ID,A）值分别为(100,1),(200,2),(300,3),(500,6)和(600,6),两棵数的示例图入下：
<img src="https://huran111.github.io/post-images/1559038934132.png" alt="">
从图中看出，根据叶子节点内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点内容是整行数据，在InnoDB里，主键索引也称之为聚簇索引。</p>
<p>非主键索引的叶子节点内容是主键的值，在InnoBD里，非主键索引也被称为二级索引。</p>
<p>那么，主键和普通索引的查询有什么区别呢？</p>
<p>如果语句为select *  from T where id=600,也就是主键查询方式，则只需要搜索ID这棵B+树。</p>
<p>如果语句为select * fromT where a=6,也就是普通索引查询方式，则先搜索A索引树,得到ID的值为600，再到ID索引树搜索一次，该过程称之为回表。</p>
<p>因此，我们在日常开发中，尽量使用主键查询，避免回表。
**索引的维护
B+树维护了索引的有序性，在插入新的值的时候需要做必要的维护，以上图为例，如果插入 一个ID的值为700，则只需要在A5的记录后面插入一个新记录，如果插入ID的值为400，就相对麻烦了，需要逻辑上移动后面的数据，空出位置。</p>
<p>如果A5所在的数据页满了，根据B+数的算法，这时候需要申请一个新的数据 页，然后移动部分数据过去，这个过程为页分裂，这种情况下，性能会受到影响。</p>
<p>除了性能，页分裂还影响数据页的利用率，原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当然有分裂就有合并，系统会将数据也合并。</p>
<p>基于上述，哪些场景下应该使用自增主键，而哪些场景下不应该？</p>
<p>插入新记录的时候可以不知道ID,系统会获取当前ID最大值加1作为下一条记录的Id值。自增主键的插入数据模式，符合 递增插入的场景，每次插入一条新记录，都是追加操作，都不涉及到移动其他记录，也不会触发叶子节点的分裂。</p>
<p>假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>主键长度越小，普通索引的叶子节点就越小，由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节
什么场景下适合业务字段做主键？</p>
<p>只有一个索引</p>
<p>改索引必须是唯一索引</p>
<p>KV场景</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thread]]></title>
        <id>https://huran111.github.io/post/java-duo-xian-cheng-bi-ji</id>
        <link href="https://huran111.github.io/post/java-duo-xian-cheng-bi-ji">
        </link>
        <updated>2019-05-28T03:12:43.000Z</updated>
        <content type="html"><![CDATA[<p>线程的概念：
线程是程序中执行的线程。Java虚拟机允许应用程序同时运行多个执行线程。每个线程都有一个优先级。优先级较高的线程优先于优先级较低的线程执行。每个线程也可以标记为守护进程，也可以不标记为守护进程。当在某个线程中运行的代码创建一个新线程对象时，新线程的优先级初始设置为创建线程的优先级，并且只有当创建线程是一个守护进程时，新线程才是守护进程。当Java虚拟机启动时，通常有一个非守护进程线程(它通常调用一些指定类的main方法)。Java虚拟机继续执行线程，直到下列情况之一发生:
+ 调用了类运行时的退出方法，并且安全管理器允许执行退出操作。
+ 不是守护进程线程的所有线程都已死亡，要么从对run方法的调用返回，要么抛出一个在run方法之外传播的异常。</p>
<hr>
<ul>
<li>线程的创建方式
<ul>
<li>继承Thread类</li>
<li>实现Rubbable接口</li>
<li>实现Callable接口</li>
</ul>
</li>
<li>线程的六种状态
<ul>
<li>NEW 尚未启动的线程处于此状态。
<ul>
<li>线程尚未启动的时候的状态 也就是NEW出来的时候。</li>
</ul>
</li>
<li>RUNNABLE 在 java虚拟机中执行的线程处于此状态。
<ul>
<li>可运行线程的线程状态。 可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统（例如处理器）的其他资源。</li>
</ul>
</li>
<li>BLOCKED  等待监视器锁的阻塞线程的线程状态。
<ul>
<li>一个线程的线程状态阻塞等待监视器锁定。 处于阻塞状态的线程正在等待监视器锁定进入同步块/方法，或者在调用Object.wait后重新输入同步的块/方法。</li>
</ul>
</li>
<li>WAITING 正在等待另一个线程执行特定动作的线程处于此状态。
<ul>
<li>等待线程的线程状态 由于调用以下方法之一，线程处于等待状态：
<ul>
<li>Object.wait没有超时</li>
<li>Thread.join没有超时</li>
<li>LockSupport.park</li>
<li>等待状态的线程正在等待另一个线程执行特定的动作。 例如，已经在对象上调用Object.wait()线程正在等待另一个线程调用该对象上Object.notify() Object.notifyAll()或。 调用Thread.join()的线程正在等待指定的线程终止</li>
</ul>
</li>
</ul>
</li>
<li>TIMED_WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
<ul>
<li>具有指定等待时间的等待线程的线程状态。 线程处于定时等待状态，因为在指定的正等待时间内调用以下方法之一：
<ul>
<li>Thread.sleep</li>
<li>Object.wait与超时</li>
<li>Thread.join与超时</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
</li>
</ul>
</li>
<li>TEARMINATED 已退出的线程处于此状态。
<ul>
<li>终止线程的线程状态。 线程已完成执行。</li>
</ul>
</li>
<li>ThreadFactory
<ul>
<li>根据需要创建新线程的对象。 使用线程工厂可以删除new Thread的硬连线 ，使应用程序能够使用特殊的线程子类，优先级等。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>