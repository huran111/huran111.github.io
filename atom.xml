<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huran111.github.io</id>
    <title>生有涯-知无涯</title>
    <updated>2019-06-06T07:43:12.396Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huran111.github.io"/>
    <link rel="self" href="https://huran111.github.io/atom.xml"/>
    <subtitle>知其然，知其所以然</subtitle>
    <logo>https://huran111.github.io/images/avatar.png</logo>
    <icon>https://huran111.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 生有涯-知无涯</rights>
    <entry>
        <title type="html"><![CDATA[JVM常用参数]]></title>
        <id>https://huran111.github.io/post/jvm-chang-yong-can-shu</id>
        <link href="https://huran111.github.io/post/jvm-chang-yong-can-shu">
        </link>
        <updated>2019-06-06T06:33:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>-XX:+PrintGCDetails
<ul>
<li><img src="https://huran111.github.io/post-images/1559803668436.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1559803679533.png" alt=""></li>
<li>FullGC</li>
<li><img src="https://huran111.github.io/post-images/1559804512979.png" alt=""></li>
<li>SurvivorRatio 占比
<ul>
<li><img src="https://huran111.github.io/post-images/1559804960529.png" alt=""></li>
</ul>
</li>
<li>-XX:NewRatio 设置新生代和老年代的占比</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM布局]]></title>
        <id>https://huran111.github.io/post/jvm-bu-ju</id>
        <link href="https://huran111.github.io/post/jvm-bu-ju">
        </link>
        <updated>2019-06-05T09:19:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>引用计数法</li>
<li><img src="https://huran111.github.io/post-images/1559726465618.png" alt=""></li>
<li>缺点</li>
<li>每次对对象复制时要维护引用计数器，且计数器本身也有一定的消耗，较难处理循环引用</li>
<li>JVM实现一般不采用这种方式</li>
<li>复制算法</li>
<li>java堆从GC的角度还可以细分为：新生代(Eden区，From Survivor区和 To Survivor 区) 和老年代。</li>
<li><img src="https://huran111.github.io/post-images/1559727044616.png" alt=""></li>
<li>Eden，From复制到TO，年龄加1，首先，当Eden区满的时候，会出发一个GC,把还活着的对象拷贝到From区，当Eden区再次触发GC的时候会扫描Eden区和From区，对这两个区域进行垃圾回收，经过这次回收后还活着的对象，直接复制到TO区域，如果有对象符合老年代的标准，则进入老年代，同时把这些对象年龄加1</li>
<li>然后，情况Eden和From中的对象，复制交换，谁空谁是TO</li>
<li>标记清除法
<ul>
<li>分成标记和清除，先标记出要回收的对象，然后统一回收这些对象</li>
<li><img src="https://huran111.github.io/post-images/1559727435884.png" alt=""></li>
<li>JVM如何确定它是个垃圾
<ul>
<li>简单来说就是内存中不在使用到的空间就是垃圾</li>
<li>引用计数法，根节点的可达性</li>
<li>哪些可以作为GC ROOT对象呢
<ul>
<li>虚拟机栈中引用的对象（局部变量表）</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象
+ 本地方法栈中JNI引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JVM参数类型
<ul>
<li>标配参数  -version  -help</li>
<li>X参数</li>
<li>XX参数</li>
</ul>
</li>
<li>查看jvm初始值 java -XX:+PrintFlagsInitial</li>
<li><img src="https://huran111.github.io/post-images/1559783486769.png" alt=""></li>
<li>查看修改更新的的内容 java -XX:+PrintFlagsFinal -version</li>
<li><img src="https://huran111.github.io/post-images/1559783626146.png" alt=""></li>
<li>java -XX:+PrintCommandLineFlags -version</li>
<li><img src="https://huran111.github.io/post-images/1559799722070.png" alt=""></li>
<li>JVM常用基本配置</li>
<li>元空间和永久代的最大区别在于永久代使用的是JVM的堆内存，但是java8以后元空间并不在虚拟机中而是使用的物理内存。</li>
<li>常用参数
+ -Xms: 初始化大小内存，默认为物理内存的 1/64 等价于 -XX:InitialHeapSize
+ -Xmx: 最大分配内存，默认物理内存的1/4  等价于 -XX:MaxHeapSize
+ -Xss : 设置单个线程栈的大小，一般默认为512-1024K 等价于-XX:ThreadStackSize
+ -Xmn: 设置年轻代大小
+ -XX:MetaspaceSize
+ 元空间的大小受本地内存限制
+ 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
1、字符串存在永久代中，容易出现性能问题和内存溢出。
　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
　4、Oracle 可能会将HotSpot 与 JRockit 合二为一</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO流]]></title>
        <id>https://huran111.github.io/post/io-liu</id>
        <link href="https://huran111.github.io/post/io-liu">
        </link>
        <updated>2019-06-05T04:24:54.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>字节流：按照字节入去数据（InputStream，OutputStream）</li>
<li>字符流：按照字符读取数据（Reader，Writer），因为文件的编码不同，从而有了对字符进行高效操作的字符流对象
<ul>
<li>原理：底层还是基于字节流，自动所寻了制定的码表。</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ThreadPoolExecutor]]></title>
        <id>https://huran111.github.io/post/threadpoolexecutor</id>
        <link href="https://huran111.github.io/post/threadpoolexecutor">
        </link>
        <updated>2019-06-04T05:29:55.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ThreadPoolExecuto
<ul>
<li><img src="https://huran111.github.io/post-images/1559638580944.png" alt=""></li>
</ul>
</li>
<li>线程池的执行流程</li>
<li><img src="https://huran111.github.io/post-images/1559639322246.png" alt=""></li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列]]></title>
        <id>https://huran111.github.io/post/zu-sai-dui-lie</id>
        <link href="https://huran111.github.io/post/zu-sai-dui-lie">
        </link>
        <updated>2019-06-03T02:14:25.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>ArrayBlockingQueue 是一个基于数据结构的有界阻塞队列，此队列按照FIFO原则对元素进行排序</p>
</li>
<li>
<p>LinkedBlockingQueue 一个基于链表结构的阻塞队列，按照FIFO，吞吐量大于ArrayBlockingQueue（有界）</p>
</li>
<li>
<p>SynchronusQueue 一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量高。</p>
</li>
<li>
<p>PriorityBlockingQueue: 支持优先级的无界阻塞队列</p>
</li>
<li>
<p>DelayQueue:使用优先级队列实现的延迟无界阻塞队列</p>
</li>
<li>
<p>LinkedTransferQueue:由链表结构组成的无界阻塞队列</p>
</li>
<li>
<p>LinkedBlockingDeque:由链表结构组成的双向阻塞队列</p>
</li>
<li>
<p>阻塞队列</p>
<ul>
<li>阻塞队列好不好</li>
<li>如何管理</li>
</ul>
</li>
<li>
<p>BlockingQueue的核心方法
<img src="https://huran111.github.io/post-images/1559530754157.png" alt="">
<img src="https://huran111.github.io/post-images/1559530901249.png" alt=""></p>
</li>
<li>
<p>队列满了报异常，队列空了报异常</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531013086.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531060863.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531074612.png" alt=""></p>
</li>
<li>
<p>不报异常</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531230279.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531357483.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531551838.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531793101.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559532132591.png" alt=""></p>
</li>
<li>
<p>SynchronusQueue</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559532512220.png" alt=""></p>
</li>
<li>
<p>两个线程一个加一个减</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559540593074.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559540599595.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559540605293.png" alt=""></p>
</li>
<li>
<p>synchronizd和lock的区别</p>
<ul>
<li>synchronizd 不需要用户手动去释放锁，当synchronizd代码块执行的时候系统会自动让现场释放对锁的占用，需要lock和unlock方法配合使用</li>
<li>synchronizd 不可中断，除非抛出异常和正常退出</li>
<li>ReentrantLock 可中断，可设置超时</li>
<li>synchronizd 是非公平锁，</li>
<li>ReentrantLock可以绑定多个条件</li>
</ul>
</li>
<li>
<p>A-B-C三个线程相互调用
<img src="https://huran111.github.io/post-images/1559542850687.png" alt="">
<img src="https://huran111.github.io/post-images/1559542858546.png" alt="">
<img src="https://huran111.github.io/post-images/1559542870155.png" alt="">
<img src="https://huran111.github.io/post-images/1559542881257.png" alt=""></p>
</li>
<li>
<p>阻塞队列版本</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559560990288.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559561001147.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559561007626.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559561012205.png" alt=""></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自旋锁，独占锁，共享锁]]></title>
        <id>https://huran111.github.io/post/zi-xuan-suo</id>
        <link href="https://huran111.github.io/post/zi-xuan-suo">
        </link>
        <updated>2019-06-03T00:48:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="自旋锁">自旋锁</h3>
<ul>
<li>是指尝试获取的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处就是减少线程上下文切换的消耗，缺点是循环会消耗CPU.
<img src="https://huran111.github.io/post-images/1559523394198.png" alt=""></li>
<li>手写一个自旋锁
<img src="https://huran111.github.io/post-images/1559524541420.png" alt="">
<img src="https://huran111.github.io/post-images/1559524551437.png" alt=""></li>
</ul>
<h3 id="独占锁">独占锁</h3>
<ul>
<li>共享锁：指改锁可被多个线程持有
<ul>
<li>对于ReentantReadWriteLock其读锁是共享锁，其写锁是独占锁</li>
<li>读锁的共享锁可以保证并发读是非常高效的，读写，写读，写写过程是互斥的</li>
</ul>
</li>
<li>读写锁案例
<ul>
<li>读读可共存，读写，写写不可共存
<img src="https://huran111.github.io/post-images/1559527061678.png" alt="">
<img src="https://huran111.github.io/post-images/1559527068671.png" alt="">
<img src="https://huran111.github.io/post-images/1559527075194.png" alt="">
<img src="https://huran111.github.io/post-images/1559527118621.png" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不安全的集合]]></title>
        <id>https://huran111.github.io/post/bu-an-quan-de-ji-he</id>
        <link href="https://huran111.github.io/post/bu-an-quan-de-ji-he">
        </link>
        <updated>2019-06-02T10:26:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ArrayLis
<img src="https://huran111.github.io/post-images/1559471218693.png" alt="">
<ul>
<li>排除异常为：ConcurrentModificationException</li>
<li>解决
<ul>
<li>List<String> list = Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list =new CopyOnWriteArrayList&lt;&gt;(); (使用与读多写少，否则很慢)</li>
<li>CopyOnWriteArrayList</li>
<li></li>
</ul>
</li>
<li>导致的原因
+</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原子引用和ABA问题]]></title>
        <id>https://huran111.github.io/post/yuan-zi-yin-yong</id>
        <link href="https://huran111.github.io/post/yuan-zi-yin-yong">
        </link>
        <updated>2019-06-02T08:36:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>原子引用
<img src="https://huran111.github.io/post-images/1559465629149.png" alt=""></li>
<li>原子引用+版本号（解决ABA问题）类似版本号</li>
<li>ABA产生演示：
<img src="https://huran111.github.io/post-images/1559466969163.png" alt="">
<img src="https://huran111.github.io/post-images/1559467989470.png" alt=""></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单利模式下可能存在的安全性问题]]></title>
        <id>https://huran111.github.io/post/dan-li-mo-shi-xia-ke-neng-cun-zai-de-an-quan-xing-wen-ti</id>
        <link href="https://huran111.github.io/post/dan-li-mo-shi-xia-ke-neng-cun-zai-de-an-quan-xing-wen-ti">
        </link>
        <updated>2019-06-02T06:15:07.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>第一种
<img src="https://huran111.github.io/post-images/1559456638703.png" alt="">
<ul>
<li>单线程下加上synchronized可以解决该问题，但是在高并发情况下，很消耗性能</li>
</ul>
</li>
<li>DCL(双重检查锁)
<img src="https://huran111.github.io/post-images/1559456993966.png" alt=""></li>
<li>双端检锁机制不一定安全，原因是指令重排序，在于某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象可能没有完成初始化。
<img src="https://huran111.github.io/post-images/1559458772074.png" alt=""></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://huran111.github.io/post/gong-han-mo-shi</id>
        <link href="https://huran111.github.io/post/gong-han-mo-shi">
        </link>
        <updated>2019-05-31T01:54:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code>1.首先，我们明确一点，我们不应该针对实现编程，但是当我们每次使用new的时候，不正是在针对实现编程么？
</code></pre>
<p><img src="https://huran111.github.io/post-images/1559268374740.png" alt=""></p>
<ul>
<li>认识变化的方面
<img src="https://huran111.github.io/post-images/1559269101158.png" alt=""></li>
<li>但是压力就是来自于更多的披萨
<img src="https://huran111.github.io/post-images/1559269422754.png" alt=""></li>
<li>现在我们已经知道了哪里会发生变化，是时候开始封装了
<img src="https://huran111.github.io/post-images/1559270009251.png" alt=""></li>
<li>工厂处理创建对象的细节，一旦有了工厂，创建对象的时候，就叫工厂做一个，现在orderPizza()方法只是关心从工厂得到了一个披萨，而所有的类型披萨都实现了Pizza接口它们的bake(),cut(),box都可以通用。
<img src="https://huran111.github.io/post-images/1559271214457.png" alt=""></li>
<li>有人会问，这不还是一样么？只是把搬到另外一个对象里面罢了。
<ul>
<li>但是别忘了，SimplePizzaFactory可以有很多的客户，不仅仅只有orderPizza()这个方法，所以，当以后实现改变的时候，只需要修改这个类即可。</li>
<li>静态工厂不需要使用创建对象的方法来实例化对象，但是，它不能通过继承来改变创建方法的行为。</li>
</ul>
</li>
<li>重做披萨类
<img src="https://huran111.github.io/post-images/1559271869245.png" alt=""></li>
<li>定义简单工厂
<img src="https://huran111.github.io/post-images/1559272255417.png" alt=""></li>
<li>如果有很多不同的披萨加盟店，根据地域不同风味也不同，怎么办？
<ul>
<li>我么可以写出三种不同的工厂，分别负责创建不同区域的披萨。（VarPizzaFactory,Var2PizzaFactory,Var3PizzaFactory）
<img src="https://huran111.github.io/post-images/1559272741289.png" alt=""></li>
<li>我们把createPizza()方法放回到PizzaStore类中，把它设置为抽象。
<img src="https://huran111.github.io/post-images/1559273553779.png" alt="">
<ul>
<li>现在已经有了一个PizzaStore作为超类，让每个区域的类型都继承这个超类，各自实现制造披萨。
<img src="https://huran111.github.io/post-images/1559273831614.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>