<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huran111.github.io</id>
    <title>生有涯-知无涯</title>
    <updated>2019-06-14T16:02:30.525Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huran111.github.io"/>
    <link rel="self" href="https://huran111.github.io/atom.xml"/>
    <subtitle>知其然，知其所以然</subtitle>
    <logo>https://huran111.github.io/images/avatar.png</logo>
    <icon>https://huran111.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 生有涯-知无涯</rights>
    <entry>
        <title type="html"><![CDATA[MyBatis原理]]></title>
        <id>https://huran111.github.io/post/mybatis-yuan-li</id>
        <link href="https://huran111.github.io/post/mybatis-yuan-li">
        </link>
        <updated>2019-06-14T02:53:03.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>主要构件及其相互关系</li>
<li>SqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li>
<li>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li>
<li>StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合</li>
<li>ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所需要的参数；</li>
<li>ResultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</li>
<li>TypeHandler：负责java数据类型和jdbc数据类型之间的映射和转换；</li>
<li>MappedStatement：MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装；</li>
<li>SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li>BoundSql：表示动态生成的SQL语句以及相应的参数信息；</li>
<li>Configuration：MyBatis所有的配置信息都维持在Configuration对象之中；</li>
<li><img src="https://huran111.github.io/post-images/1560488110683.png" alt=""></li>
<li>首先，我们来看一个例子</li>
<li><img src="https://huran111.github.io/post-images/1560489148557.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560489191829.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560489203828.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560489385433.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491269325.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491303104.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491340414.png" alt=""></li>
<li>缓存的是一个CacheKey Value</li>
<li><img src="https://huran111.github.io/post-images/1560491716290.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560491705903.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560492719898.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560493255091.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560493539131.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560495706338.png" alt=""></li>
<li>Executor的功能和作用是</li>
<li>根据传递的参数，完成SQL语句的动态解析，生成BoundSql对象，供StatementHandler使用</li>
<li>为查询创建缓存，以提高性能；</li>
<li>创建JDBC的Statement连接对象，传递给StatementHandler对象，返回List查询结果；</li>
<li>StatementHandler对象负责设置Statement对象中的查询参数、处理JDBC返回的resultSet，将resultSet加工为List 集合返回</li>
<li>prepareStatement() 方法的实现</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis(一)]]></title>
        <id>https://huran111.github.io/post/mybatisyi</id>
        <link href="https://huran111.github.io/post/mybatisyi">
        </link>
        <updated>2019-06-14T02:25:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>在resources目录下创建mybatis-config.xml</li>
<li><img src="https://huran111.github.io/post-images/1560479212794.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560479266383.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560479287311.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1560479302693.png" alt=""></li>
<li>SqlSessionFactoryBuilder
<ul>
<li>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。</li>
</ul>
</li>
<li>SqlSessionFactory
<ul>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</li>
</ul>
</li>
<li>SqlSession
<ul>
<li>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。 换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭</li>
</ul>
</li>
<li>映射器实例
<ul>
<li>映射器是一些由你创建的、绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。 并不需要显式地关闭映射器实例，尽管在整个请求作用域保持映射器实例也不会有什么问题，但是你很快会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。 为了避免这种复杂性，最好把映射器放在方法作用域内</li>
</ul>
</li>
<li>Mybatis-Executor
<ul>
<li>qlSession内部维护了一个Executor，我们实际进行的增删改查都是通过这个Executor来进行的</li>
<li><img src="https://huran111.github.io/post-images/1560479812756.png" alt=""></li>
<li>SimpleExecutor是最简单的执行器，根据对应的sql直接执行即可，不会做一些额外的操作</li>
<li>BatchExecutor执行器，顾名思义，通过批量操作来优化性能。通常需要注意的是批量更新操作，由于内部有缓存的实现，使用完成后记得调用flushStatements来清除缓存。</li>
<li>ReuseExecutor 可重用的执行器，重用的对象是Statement，也就是说该执行器会缓存同一个sql的Statement，省去Statement的重新创建，优化性能。内部的实现是通过一个HashMap来维护Statement对象的。由于当前Map只在该session中有效，所以使用完成后记得调用flushStatements来清除Map，private final Map&lt;String, Statement&gt; statementMap = new HashMap&lt;String, Statement&gt;();</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java四个引用的理解]]></title>
        <id>https://huran111.github.io/post/java-si-ge-yin-yong-de-li-jie</id>
        <link href="https://huran111.github.io/post/java-si-ge-yin-yong-de-li-jie">
        </link>
        <updated>2019-06-06T07:43:13.000Z</updated>
        <content type="html"><![CDATA[<p>·</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM常用参数]]></title>
        <id>https://huran111.github.io/post/jvm-chang-yong-can-shu</id>
        <link href="https://huran111.github.io/post/jvm-chang-yong-can-shu">
        </link>
        <updated>2019-06-06T06:33:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>-XX:+PrintGCDetails
<ul>
<li><img src="https://huran111.github.io/post-images/1559803668436.png" alt=""></li>
<li><img src="https://huran111.github.io/post-images/1559803679533.png" alt=""></li>
<li>FullGC</li>
<li><img src="https://huran111.github.io/post-images/1559804512979.png" alt=""></li>
<li>SurvivorRatio 占比
<ul>
<li><img src="https://huran111.github.io/post-images/1559804960529.png" alt=""></li>
</ul>
</li>
<li>-XX:NewRatio 设置新生代和老年代的占比</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM布局]]></title>
        <id>https://huran111.github.io/post/jvm-bu-ju</id>
        <link href="https://huran111.github.io/post/jvm-bu-ju">
        </link>
        <updated>2019-06-05T09:19:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>引用计数法</li>
<li><img src="https://huran111.github.io/post-images/1559726465618.png" alt=""></li>
<li>缺点</li>
<li>每次对对象复制时要维护引用计数器，且计数器本身也有一定的消耗，较难处理循环引用</li>
<li>JVM实现一般不采用这种方式</li>
<li>复制算法</li>
<li>java堆从GC的角度还可以细分为：新生代(Eden区，From Survivor区和 To Survivor 区) 和老年代。</li>
<li><img src="https://huran111.github.io/post-images/1559727044616.png" alt=""></li>
<li>Eden，From复制到TO，年龄加1，首先，当Eden区满的时候，会出发一个GC,把还活着的对象拷贝到From区，当Eden区再次触发GC的时候会扫描Eden区和From区，对这两个区域进行垃圾回收，经过这次回收后还活着的对象，直接复制到TO区域，如果有对象符合老年代的标准，则进入老年代，同时把这些对象年龄加1</li>
<li>然后，情况Eden和From中的对象，复制交换，谁空谁是TO</li>
<li>标记清除法
<ul>
<li>分成标记和清除，先标记出要回收的对象，然后统一回收这些对象</li>
<li><img src="https://huran111.github.io/post-images/1559727435884.png" alt=""></li>
<li>JVM如何确定它是个垃圾
<ul>
<li>简单来说就是内存中不在使用到的空间就是垃圾</li>
<li>引用计数法，根节点的可达性</li>
<li>哪些可以作为GC ROOT对象呢
<ul>
<li>虚拟机栈中引用的对象（局部变量表）</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象
+ 本地方法栈中JNI引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JVM参数类型
<ul>
<li>标配参数  -version  -help</li>
<li>X参数</li>
<li>XX参数</li>
</ul>
</li>
<li>查看jvm初始值 java -XX:+PrintFlagsInitial</li>
<li><img src="https://huran111.github.io/post-images/1559783486769.png" alt=""></li>
<li>查看修改更新的的内容 java -XX:+PrintFlagsFinal -version</li>
<li><img src="https://huran111.github.io/post-images/1559783626146.png" alt=""></li>
<li>java -XX:+PrintCommandLineFlags -version</li>
<li><img src="https://huran111.github.io/post-images/1559799722070.png" alt=""></li>
<li>JVM常用基本配置</li>
<li>元空间和永久代的最大区别在于永久代使用的是JVM的堆内存，但是java8以后元空间并不在虚拟机中而是使用的物理内存。</li>
<li>常用参数
+ -Xms: 初始化大小内存，默认为物理内存的 1/64 等价于 -XX:InitialHeapSize
+ -Xmx: 最大分配内存，默认物理内存的1/4  等价于 -XX:MaxHeapSize
+ -Xss : 设置单个线程栈的大小，一般默认为512-1024K 等价于-XX:ThreadStackSize
+ -Xmn: 设置年轻代大小
+ -XX:MetaspaceSize
+ 元空间的大小受本地内存限制
+ 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
1、字符串存在永久代中，容易出现性能问题和内存溢出。
　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
　4、Oracle 可能会将HotSpot 与 JRockit 合二为一</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO流]]></title>
        <id>https://huran111.github.io/post/io-liu</id>
        <link href="https://huran111.github.io/post/io-liu">
        </link>
        <updated>2019-06-05T04:24:54.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>字节流：按照字节入去数据（InputStream，OutputStream）</li>
<li>字符流：按照字符读取数据（Reader，Writer），因为文件的编码不同，从而有了对字符进行高效操作的字符流对象
<ul>
<li>原理：底层还是基于字节流，自动所寻了制定的码表。</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ThreadPoolExecutor]]></title>
        <id>https://huran111.github.io/post/threadpoolexecutor</id>
        <link href="https://huran111.github.io/post/threadpoolexecutor">
        </link>
        <updated>2019-06-04T05:29:55.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ThreadPoolExecuto
<ul>
<li><img src="https://huran111.github.io/post-images/1559638580944.png" alt=""></li>
</ul>
</li>
<li>线程池的执行流程</li>
<li><img src="https://huran111.github.io/post-images/1559639322246.png" alt=""></li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列]]></title>
        <id>https://huran111.github.io/post/zu-sai-dui-lie</id>
        <link href="https://huran111.github.io/post/zu-sai-dui-lie">
        </link>
        <updated>2019-06-03T02:14:25.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>ArrayBlockingQueue 是一个基于数据结构的有界阻塞队列，此队列按照FIFO原则对元素进行排序</p>
</li>
<li>
<p>LinkedBlockingQueue 一个基于链表结构的阻塞队列，按照FIFO，吞吐量大于ArrayBlockingQueue（有界）</p>
</li>
<li>
<p>SynchronusQueue 一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量高。</p>
</li>
<li>
<p>PriorityBlockingQueue: 支持优先级的无界阻塞队列</p>
</li>
<li>
<p>DelayQueue:使用优先级队列实现的延迟无界阻塞队列</p>
</li>
<li>
<p>LinkedTransferQueue:由链表结构组成的无界阻塞队列</p>
</li>
<li>
<p>LinkedBlockingDeque:由链表结构组成的双向阻塞队列</p>
</li>
<li>
<p>阻塞队列</p>
<ul>
<li>阻塞队列好不好</li>
<li>如何管理</li>
</ul>
</li>
<li>
<p>BlockingQueue的核心方法
<img src="https://huran111.github.io/post-images/1559530754157.png" alt="">
<img src="https://huran111.github.io/post-images/1559530901249.png" alt=""></p>
</li>
<li>
<p>队列满了报异常，队列空了报异常</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531013086.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531060863.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531074612.png" alt=""></p>
</li>
<li>
<p>不报异常</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531230279.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531357483.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531551838.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559531793101.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559532132591.png" alt=""></p>
</li>
<li>
<p>SynchronusQueue</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559532512220.png" alt=""></p>
</li>
<li>
<p>两个线程一个加一个减</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559540593074.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559540599595.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559540605293.png" alt=""></p>
</li>
<li>
<p>synchronizd和lock的区别</p>
<ul>
<li>synchronizd 不需要用户手动去释放锁，当synchronizd代码块执行的时候系统会自动让现场释放对锁的占用，需要lock和unlock方法配合使用</li>
<li>synchronizd 不可中断，除非抛出异常和正常退出</li>
<li>ReentrantLock 可中断，可设置超时</li>
<li>synchronizd 是非公平锁，</li>
<li>ReentrantLock可以绑定多个条件</li>
</ul>
</li>
<li>
<p>A-B-C三个线程相互调用
<img src="https://huran111.github.io/post-images/1559542850687.png" alt="">
<img src="https://huran111.github.io/post-images/1559542858546.png" alt="">
<img src="https://huran111.github.io/post-images/1559542870155.png" alt="">
<img src="https://huran111.github.io/post-images/1559542881257.png" alt=""></p>
</li>
<li>
<p>阻塞队列版本</p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559560990288.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559561001147.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559561007626.png" alt=""></p>
</li>
<li>
<p><img src="https://huran111.github.io/post-images/1559561012205.png" alt=""></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自旋锁，独占锁，共享锁]]></title>
        <id>https://huran111.github.io/post/zi-xuan-suo</id>
        <link href="https://huran111.github.io/post/zi-xuan-suo">
        </link>
        <updated>2019-06-03T00:48:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="自旋锁">自旋锁</h3>
<ul>
<li>是指尝试获取的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处就是减少线程上下文切换的消耗，缺点是循环会消耗CPU.
<img src="https://huran111.github.io/post-images/1559523394198.png" alt=""></li>
<li>手写一个自旋锁
<img src="https://huran111.github.io/post-images/1559524541420.png" alt="">
<img src="https://huran111.github.io/post-images/1559524551437.png" alt=""></li>
</ul>
<h3 id="独占锁">独占锁</h3>
<ul>
<li>共享锁：指改锁可被多个线程持有
<ul>
<li>对于ReentantReadWriteLock其读锁是共享锁，其写锁是独占锁</li>
<li>读锁的共享锁可以保证并发读是非常高效的，读写，写读，写写过程是互斥的</li>
</ul>
</li>
<li>读写锁案例
<ul>
<li>读读可共存，读写，写写不可共存
<img src="https://huran111.github.io/post-images/1559527061678.png" alt="">
<img src="https://huran111.github.io/post-images/1559527068671.png" alt="">
<img src="https://huran111.github.io/post-images/1559527075194.png" alt="">
<img src="https://huran111.github.io/post-images/1559527118621.png" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不安全的集合]]></title>
        <id>https://huran111.github.io/post/bu-an-quan-de-ji-he</id>
        <link href="https://huran111.github.io/post/bu-an-quan-de-ji-he">
        </link>
        <updated>2019-06-02T10:26:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ArrayLis
<img src="https://huran111.github.io/post-images/1559471218693.png" alt="">
<ul>
<li>排除异常为：ConcurrentModificationException</li>
<li>解决
<ul>
<li>List<String> list = Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list =new CopyOnWriteArrayList&lt;&gt;(); (使用与读多写少，否则很慢)</li>
<li>CopyOnWriteArrayList</li>
<li></li>
</ul>
</li>
<li>导致的原因
+</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>