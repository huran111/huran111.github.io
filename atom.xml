<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>C:/Users/BUCHU/Documents/Gridea/output</id>
    <title>生有涯-知无涯</title>
    <updated>2019-06-04T09:08:46.763Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="C:/Users/BUCHU/Documents/Gridea/output"/>
    <link rel="self" href="C:/Users/BUCHU/Documents/Gridea/output/atom.xml"/>
    <subtitle>知其然，知其所以然</subtitle>
    <logo>C:/Users/BUCHU/Documents/Gridea/output/images/avatar.png</logo>
    <icon>C:/Users/BUCHU/Documents/Gridea/output/favicon.ico</icon>
    <rights>All rights reserved 2019, 生有涯-知无涯</rights>
    <entry>
        <title type="html"><![CDATA[ThreadPoolExecutor]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/threadpoolexecutor/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/threadpoolexecutor/index.html">
        </link>
        <updated>2019-06-04T05:29:55.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ThreadPoolExecuto
<ul>
<li><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559638580944.png" alt=""></li>
</ul>
</li>
<li>线程池的执行流程</li>
<li><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559639322246.png" alt=""></li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阻塞队列]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/zu-sai-dui-lie/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/zu-sai-dui-lie/index.html">
        </link>
        <updated>2019-06-03T02:14:25.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>ArrayBlockingQueue 是一个基于数据结构的有界阻塞队列，此队列按照FIFO原则对元素进行排序</p>
</li>
<li>
<p>LinkedBlockingQueue 一个基于链表结构的阻塞队列，按照FIFO，吞吐量大于ArrayBlockingQueue（有界）</p>
</li>
<li>
<p>SynchronusQueue 一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量高。</p>
</li>
<li>
<p>PriorityBlockingQueue: 支持优先级的无界阻塞队列</p>
</li>
<li>
<p>DelayQueue:使用优先级队列实现的延迟无界阻塞队列</p>
</li>
<li>
<p>LinkedTransferQueue:由链表结构组成的无界阻塞队列</p>
</li>
<li>
<p>LinkedBlockingDeque:由链表结构组成的双向阻塞队列</p>
</li>
<li>
<p>阻塞队列</p>
<ul>
<li>阻塞队列好不好</li>
<li>如何管理</li>
</ul>
</li>
<li>
<p>BlockingQueue的核心方法
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559530754157.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559530901249.png" alt=""></p>
</li>
<li>
<p>队列满了报异常，队列空了报异常</p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531013086.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531060863.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531074612.png" alt=""></p>
</li>
<li>
<p>不报异常</p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531230279.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531357483.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531551838.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559531793101.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559532132591.png" alt=""></p>
</li>
<li>
<p>SynchronusQueue</p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559532512220.png" alt=""></p>
</li>
<li>
<p>两个线程一个加一个减</p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559540593074.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559540599595.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559540605293.png" alt=""></p>
</li>
<li>
<p>synchronizd和lock的区别</p>
<ul>
<li>synchronizd 不需要用户手动去释放锁，当synchronizd代码块执行的时候系统会自动让现场释放对锁的占用，需要lock和unlock方法配合使用</li>
<li>synchronizd 不可中断，除非抛出异常和正常退出</li>
<li>ReentrantLock 可中断，可设置超时</li>
<li>synchronizd 是非公平锁，</li>
<li>ReentrantLock可以绑定多个条件</li>
</ul>
</li>
<li>
<p>A-B-C三个线程相互调用
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559542850687.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559542858546.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559542870155.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559542881257.png" alt=""></p>
</li>
<li>
<p>阻塞队列版本</p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559560990288.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559561001147.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559561007626.png" alt=""></p>
</li>
<li>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559561012205.png" alt=""></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自旋锁，独占锁，共享锁]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/zi-xuan-suo/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/zi-xuan-suo/index.html">
        </link>
        <updated>2019-06-03T00:48:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="自旋锁">自旋锁</h3>
<ul>
<li>是指尝试获取的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处就是减少线程上下文切换的消耗，缺点是循环会消耗CPU.
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559523394198.png" alt=""></li>
<li>手写一个自旋锁
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559524541420.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559524551437.png" alt=""></li>
</ul>
<h3 id="独占锁">独占锁</h3>
<ul>
<li>共享锁：指改锁可被多个线程持有
<ul>
<li>对于ReentantReadWriteLock其读锁是共享锁，其写锁是独占锁</li>
<li>读锁的共享锁可以保证并发读是非常高效的，读写，写读，写写过程是互斥的</li>
</ul>
</li>
<li>读写锁案例
<ul>
<li>读读可共存，读写，写写不可共存
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559527061678.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559527068671.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559527075194.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559527118621.png" alt=""></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[不安全的集合]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/bu-an-quan-de-ji-he/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/bu-an-quan-de-ji-he/index.html">
        </link>
        <updated>2019-06-02T10:26:33.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>ArrayLis
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559471218693.png" alt="">
<ul>
<li>排除异常为：ConcurrentModificationException</li>
<li>解决
<ul>
<li>List<String> list = Collections.synchronizedList(new ArrayList&lt;&gt;());</li>
<li>List<String> list =new CopyOnWriteArrayList&lt;&gt;(); (使用与读多写少，否则很慢)</li>
<li>CopyOnWriteArrayList</li>
<li></li>
</ul>
</li>
<li>导致的原因
+</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原子引用和ABA问题]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/yuan-zi-yin-yong/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/yuan-zi-yin-yong/index.html">
        </link>
        <updated>2019-06-02T08:36:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>原子引用
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559465629149.png" alt=""></li>
<li>原子引用+版本号（解决ABA问题）类似版本号</li>
<li>ABA产生演示：
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559466969163.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559467989470.png" alt=""></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单利模式下可能存在的安全性问题]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/dan-li-mo-shi-xia-ke-neng-cun-zai-de-an-quan-xing-wen-ti/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/dan-li-mo-shi-xia-ke-neng-cun-zai-de-an-quan-xing-wen-ti/index.html">
        </link>
        <updated>2019-06-02T06:15:07.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>第一种
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559456638703.png" alt="">
<ul>
<li>单线程下加上synchronized可以解决该问题，但是在高并发情况下，很消耗性能</li>
</ul>
</li>
<li>DCL(双重检查锁)
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559456993966.png" alt=""></li>
<li>双端检锁机制不一定安全，原因是指令重排序，在于某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象可能没有完成初始化。
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559458772074.png" alt=""></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/gong-han-mo-shi/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/gong-han-mo-shi/index.html">
        </link>
        <updated>2019-05-31T01:54:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code>1.首先，我们明确一点，我们不应该针对实现编程，但是当我们每次使用new的时候，不正是在针对实现编程么？
</code></pre>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559268374740.png" alt=""></p>
<ul>
<li>认识变化的方面
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559269101158.png" alt=""></li>
<li>但是压力就是来自于更多的披萨
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559269422754.png" alt=""></li>
<li>现在我们已经知道了哪里会发生变化，是时候开始封装了
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559270009251.png" alt=""></li>
<li>工厂处理创建对象的细节，一旦有了工厂，创建对象的时候，就叫工厂做一个，现在orderPizza()方法只是关心从工厂得到了一个披萨，而所有的类型披萨都实现了Pizza接口它们的bake(),cut(),box都可以通用。
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559271214457.png" alt=""></li>
<li>有人会问，这不还是一样么？只是把搬到另外一个对象里面罢了。
<ul>
<li>但是别忘了，SimplePizzaFactory可以有很多的客户，不仅仅只有orderPizza()这个方法，所以，当以后实现改变的时候，只需要修改这个类即可。</li>
<li>静态工厂不需要使用创建对象的方法来实例化对象，但是，它不能通过继承来改变创建方法的行为。</li>
</ul>
</li>
<li>重做披萨类
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559271869245.png" alt=""></li>
<li>定义简单工厂
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559272255417.png" alt=""></li>
<li>如果有很多不同的披萨加盟店，根据地域不同风味也不同，怎么办？
<ul>
<li>我么可以写出三种不同的工厂，分别负责创建不同区域的披萨。（VarPizzaFactory,Var2PizzaFactory,Var3PizzaFactory）
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559272741289.png" alt=""></li>
<li>我们把createPizza()方法放回到PizzaStore类中，把它设置为抽象。
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559273553779.png" alt="">
<ul>
<li>现在已经有了一个PizzaStore作为超类，让每个区域的类型都继承这个超类，各自实现制造披萨。
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559273831614.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx基本配置与参数说明]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/nginx-ji-ben-pei-zhi-yu-can-shu-shuo-ming/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/nginx-ji-ben-pei-zhi-yu-can-shu-shuo-ming/index.html">
        </link>
        <updated>2019-05-30T08:40:30.000Z</updated>
        <content type="html"><![CDATA[<p>#运行用户
user nobody;
#启动进程,通常设置成和cpu的数量相等
worker_processes  1;</p>
<p>#全局错误日志及PID文件
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;</p>
<p>#pid        logs/nginx.pid;</p>
<p>#工作模式及连接数上限
events {
#epoll是多路复用IO(I/O Multiplexing)中的一种方式,
#仅用于linux2.6以上内核,可以大大提高nginx的性能
use   epoll;</p>
<pre><code>#单个后台worker process进程的最大并发链接数    
worker_connections  1024;

# 并发总数是 worker_processes 和 worker_connections 的乘积
# 即 max_clients = worker_processes * worker_connections
# 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么
# 为什么上面反向代理要除以4，应该说是一个经验值
# 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000
# worker_connections 值的设置跟物理内存大小有关
# 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数
# 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右
# 我们来看看360M内存的VPS可以打开的文件句柄数是多少：
# $ cat /proc/sys/fs/file-max
# 输出 34336
# 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内
# 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置
# 使得并发总数小于操作系统可以打开的最大文件数目
# 其实质也就是根据主机的物理CPU和内存进行配置
# 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。
# ulimit -SHn 65535
</code></pre>
<p>}</p>
<p>http {
#设定mime类型,类型由mime.type文件定义
include    mime.types;
default_type  application/octet-stream;
#设定日志格式
log_format  main  '$remote_addr - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi>t</mi><msub><mi>e</mi><mi>u</mi></msub><mi>s</mi><mi>e</mi><mi>r</mi><mo>[</mo></mrow><annotation encoding="application/x-tex">remote_user [</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span></span></span></span>time_local] &quot;<span class='katex-error' title='ParseError: KaTeX parse error: Double superscript at position 34: …               &#039;̲'>request&quot; &#039;
                      &#039;</span>status <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>d</mi><msub><mi>y</mi><mi>b</mi></msub><mi>y</mi><mi>t</mi><mi>e</mi><msub><mi>s</mi><mi>s</mi></msub><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">body_bytes_sent &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">&quot;</span></span></span></span>http_referer&quot; '
'&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>t</mi><mi>t</mi><msub><mi>p</mi><mi>u</mi></msub><mi>s</mi><mi>e</mi><msub><mi>r</mi><mi>a</mi></msub><mi>g</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">http_user_agent&quot; &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">&quot;</span><span class="mord">&quot;</span></span></span></span>http_x_forwarded_for&quot;';</p>
<pre><code>access_log  logs/access.log  main;

#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，
#对于普通应用，必须设为 on,
#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，
#以平衡磁盘与网络I/O处理速度，降低系统的uptime.
sendfile     on;
#tcp_nopush     on;

#连接超时时间
#keepalive_timeout  0;
keepalive_timeout  65;
tcp_nodelay     on;

#开启gzip压缩
gzip  on;
gzip_disable &quot;MSIE [1-6].&quot;;

#设定请求缓冲
client_header_buffer_size    128k;
large_client_header_buffers  4 128k;


#设定虚拟主机配置
server {
    #侦听80端口
    listen    80;
    #定义使用 www.nginx.cn访问
    server_name  www.nginx.cn;

    #定义服务器的默认网站根目录位置
    root html;

    #设定本虚拟主机的访问日志
    access_log  logs/nginx.access.log  main;

    #默认请求
    location / {
        
        #定义首页索引文件的名称
        index index.php index.html index.htm;   

    }

    # 定义错误提示页面
    error_page   500 502 503 504 /50x.html;
    location = /50x.html {
    }

    #静态文件，nginx自己处理
    location ~ ^/(images|javascript|js|css|flash|media|static)/ {
        
        #过期30天，静态文件不怎么更新，过期可以设大一点，
        #如果频繁更新，则可以设置得小一点。
        expires 30d;
    }

    #禁止访问 .htxxx 文件
        location ~ /.ht {
        deny all;
    }

}
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx（一）]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/nginxyi/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/nginxyi/index.html">
        </link>
        <updated>2019-05-30T08:11:59.000Z</updated>
        <content type="html"><![CDATA[<h4 id="nginx是什么">Nginx是什么</h4>
<ul>
<li>
<p>Nginx是一个代理服务器
**一个完整的代理请求：</p>
</li>
<li>
<p>客户端先与代理服务器创建连接</p>
</li>
<li>
<p>然后根据代理服务器所使用的协议，请求对目标服务器创建连接，或获取目标服务器的指定资源。
**Nginx的特定</p>
</li>
<li>
<p>跨平台</p>
</li>
<li>
<p>配置异常简单</p>
</li>
<li>
<p>阻塞、高并发连接：数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能够支撑5万并发连接，在实际生产环境中跑到2～3万并发连接数</p>
</li>
<li>
<p>事件驱动：通信机制采用epoll模型，支持更大的并发连接</p>
</li>
<li>
<p>master/worker结构：一个master进程，生成一个或多个worker进程</p>
</li>
<li>
<p>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个Nginx 进程才消耗150M内存（15M*10=150M）</p>
</li>
<li>
<p>节省带宽：支持 GZIP 压缩，可以添加浏览器本地缓存的 Header 头。</p>
</li>
<li>
<p>稳定性高：用于反向代理，宕机的概率微乎其微
**什么是事件驱动？</p>
</li>
<li>
<p>非阻塞通过不断检查事件的状态来判断是否进行读写操作，这样带来的开销很大。</p>
</li>
<li>
<p>通过异步非阻塞的事件处理机制，Nginx实现由进程循环处理多个准备好的事件，从而实现高并发和轻量级</p>
</li>
<li>
<p>。他们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制解决了我们上面两个问题。 （select/poll/epoll/kqueue）</p>
</li>
<li>
<p>以epoll为例：当事件没有准备好时，就放入epoll(队列)里面。如果有事件准备好了，那么就去处理；如果事件返回的是EAGAIN，那么继续将其放入epoll里面。从而，只要有事件准备好了，我们就去处理她，只有当所有时间都没有准备好时，才在epoll里面等着。这样 ，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理 解为循环处理多个准备好的事件，事实上就是这样的
**Nginx内部的模型
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559205024191.png" alt=""></p>
</li>
<li>
<p>nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控 worker进程的运行状态,当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网 络事件，则是放在worker进程中来处理了 。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的 。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。 worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的</p>
</li>
<li>
<p>Master接收到信号以后怎样进行处理（./nginx -s reload ）?首先master进程在接到信号后，会先重新加载配置文件，然后再启动新的进程，并向所有老的进程发送信号，告诉他们可以光荣退休了。新的进程在启动后，就开始接收新的请求，而老的进程在收到来自 master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出 .</p>
</li>
<li>
<p>worker进程又是如何处理请求的呢？我们前面有提到，worker进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个worker进程都是从master 进程fork(分配)过来，在master进程里面，先建立好需要listen的socket之后，然后再fork出多个worker进程，这样每个worker进程都可以去accept这个socket(当然不是同一个socket，只是每个进程的这个socket会监控在同一个ip地址与端口，这个在网络协议里面是允许的)。一般来说，当一个连接进来后，所有在accept在这个socket上面的进程，都会收到通知，而只有一个进程可以accept这个连接，其它的则accept失败，这是所谓的惊群现象。当然，nginx也不会视而不见，所以nginx提供了一个accept_mutex这个东西，从名字上，我们可以看这是一个加在accept上的一把共享锁。有了这把锁之后，同一时刻，就只会有一个进程在accpet连接，这样就不会有惊群问题了。accept_mutex是一个可控选项，我们可以显示地关掉，默认是打开的。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。
**Nginx是如何处理一个请求</p>
</li>
<li>
<p>首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面，先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的ip地址端口，再listen)，然后再fork(一个现有进程可以调用fork函数创建一个 新进程。由fork创建的新进程被称为子进程 )出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向nginx发起连接了。当客户端与nginx进行三次握手，与nginx建立好一个连接后，此时，某一个子进程会accept成功，得到这个建立好的连接的 socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</p>
</li>
</ul>
<p>当然，nginx也是可以作为客户端来请求其它server的数据的（如upstream模块），此时，与其它server创建的连接，也封装在ngx_connection_t中。作为客户端，nginx先获取一个ngx_connection_t结构体，然后创建socket，并设置socket的属性（ 比如非阻塞）。然后再通过添加读写事件，调用connect/read/write来调用连接，最后关掉连接，并释放ngx_connection_t。</p>
<p>nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>
<p>在这里，很多人会误解worker_connections这个参数的意思，认为这个值就是nginx所能建立连接的最大值。其实不然，这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然 ，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。
**Nginx的特点</p>
<ul>
<li>nginx代理和后端web服务器间无需长连接；</li>
<li>接收用户请求是异步的，即先将用户请求全部接收下来，再一次性发送后后端web服务器，极大的减轻后端web服务器的压力</li>
<li>发送响应报文时，是边接收来自后端web服务器的数据，边发送给客户端的</li>
<li>网络依赖型低。NGINX对网络的依赖程度非常低，理论上讲，只要能够ping通就可以实施负载均衡，而且可以有效区分内网和外网流量</li>
<li>支持服务器检测。NGINX能够根据应用服务器处理页面返回的状态码、超时信息等检测服务器是否出现故障，并及时返回错误的请求重新提交到其它节点上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成环境多线程使用]]></title>
        <id>C:/Users/BUCHU/Documents/Gridea/output/post/sheng-cheng-huan-jing-duo-xian-cheng-shi-yong/index.html</id>
        <link href="C:/Users/BUCHU/Documents/Gridea/output/post/sheng-cheng-huan-jing-duo-xian-cheng-shi-yong/index.html">
        </link>
        <updated>2019-05-29T03:29:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="threadpoolexecutor简介">ThreadPoolExecutor简介：</h3>
<p><img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100567965.png" alt="">
int corePoolSize：该线程池中核心线程数最大值</p>
<p>核心线程：线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。
如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉</p>
<p>int maximumPoolSize： 该线程池中线程总数最大值</p>
<p>线程总数 = 核心线程数 + 非核心线程数。</p>
<p>long keepAliveTime：该线程池中非核心线程闲置超时时长</p>
<p>一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉，如果设置allowCoreThreadTimeOut = true，则会作用于核心线程。</p>
<p>TimeUnit unit：keepAliveTime的单位</p>
<p>TimeUnit是一个枚举类型，其包括：
NANOSECONDS ： 1微毫秒 = 1微秒 / 1000
MICROSECONDS ： 1微秒 = 1毫秒 / 1000
MILLISECONDS ： 1毫秒 = 1秒 /1000
SECONDS ： 秒
MINUTES ： 分
HOURS ： 小时
DAYS ： 天
BlockingQueue workQueue：该线程池中的任务队列：维护着等待执行的Runnable对象</p>
<p>当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。</p>
<ul>
<li>SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大</li>
<li>LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</li>
<li>ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</li>
<li>DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</li>
<li>ThreadFactory threadFactory：创建线程的方式，这是一个接口，你new他的时候需要实现他的Thread newThread(Runnable r)方法，一般用不上。</li>
<li>RejectedExecutionHandler handler：这玩意儿就是抛出异常专用的，比如上面提到的两个错误发生了，就会由这个handler抛出异常</li>
<li>线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务，线程数量达到了corePools，则将任务移入队列等待，队列已满，新建线程(非核心线程)执行任务，队列已满，总线程数又达到了maximumPoolSize，就会由(RejectedExecutionHandler)抛出异常</li>
</ul>
<h3 id="countdownlatch">CountDownLatch</h3>
<p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务.</p>
<h3 id="future和callable">Future和Callable:</h3>
<p>Callable接口代表一段可以调用并返回结果的代码;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p>
<p>Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法在线程池中执行Callable内的任务。由于Callable任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。
java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。</p>
<h3 id="semaphore">semaphore:</h3>
<p>Semaphore是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。
**案例：
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100823289.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100829756.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100837942.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100843372.png" alt="">
案例二：
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100853506.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100858927.png" alt="">
可见耗时为：
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100867625.png" alt="">
案例三：使用多线程
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100877491.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100891871.png" alt="">
耗时： 很明显 快了太多
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100903945.png" alt="">
在并发数目较多的场景下可以加入Semaphore:
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100913600.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100919322.png" alt="">
扩展：开发小技巧
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100931806.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100938350.png" alt="">
<img src="C:/Users/BUCHU/Documents/Gridea/output/post-images/1559100944837.png" alt=""></p>
]]></content>
    </entry>
</feed>